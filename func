void ICACHE_FLASH_ATTR application_increament_time_components(void)
{
	//INCREMENT TIME COMPONENTS BASED ON THE LAST VALUE
	//AND THE 1 SECOND TIMER TICK. THIS IS USED TO INCREAMENT
	//THE TIME WHEN THE TIME IS NOT RECEIVED FROM NTP

	NTP_TIME->sec++;
	NTP_TIME->draw_update_flag |= 0b00000001;

	if(NTP_TIME->sec == 60)
	{
		NTP_TIME->sec = 0;
		NTP_TIME->min++;
		NTP_TIME->draw_update_flag |= 0b00000010;
	}

	if(NTP_TIME->min == 60)
	{
		NTP_TIME->min = 0;
		NTP_TIME->hour++;
		NTP_TIME->draw_update_flag |= 0b00000100;
	}

	if(NTP_TIME->hour == 24)
	{
		NTP_TIME->hour = 0;
		NTP_TIME->date++;
		NTP_TIME->day++;
		if(NTP_TIME->day == 8)
		{
			NTP_TIME->day = 1;
		}
		NTP_TIME->draw_update_flag |= 0b00001000;
		NTP_TIME->draw_update_flag |= 0b01000000;
	}

	//date (number of days in month) depend on
	//month and leap year(february)
	if(NTP_TIME->date > days_in_month[(NTP_TIME->month+10)%12])
	{
		//check if its february in a leap year
		if(NTP_TIME->date == 29 && NTP_TIME->month == 2 && application_check_leap_year(NTP_TIME->year)==1)
		{
			//its february 29 in a leap year. do nothing
		}
		else
		{
			NTP_TIME->date = 1;
			NTP_TIME->month++;
			NTP_TIME->draw_update_flag |= 0b00010000;
		}
	}

	if(NTP_TIME->month == 13)
	{
		NTP_TIME->month = 1;
		NTP_TIME->year++;
		NTP_TIME->draw_update_flag |= 0b00100000;
	}
}


void ICACHE_FLASH_ATTR application_get_time_components_from_ntp_timestamp(void)
{
	//CALCULATE THE TIME COMPONENTS FROM THE 32 BIT TIMESTAMP
	//AND SAVE IN GLOBAL TIME STRUCTURE

	//CONVERT TIMESTAMP TO DATE/TIME VALUES
	//REFERENCE : http://git.musl-libc.org/cgit/musl/plain/src/time/__secs_to_tm.c?h=v0.9.15

	//	YEAR 		(BASE 2000)
	//	MONTH 		(JANUARY = 1)
	//	DATE 		(1 BASED)
	//	WEEKDAY		(MONDAY = 1)
	//	HOUR
	//	MINUTE
	//	SECOND

	//UTC OFFSET INDIA (GMT + 5:30)
	uint32_t india_utc_offset_seconds = (5*3600) + (30*60);

	uint64_t secs = NTP_TIME->time_tick;
	secs += india_utc_offset_seconds;
	secs -= LEAPOCH;

	uint32_t days = secs / 86400;
	uint32_t rem_secs = secs % 86400;

	if(rem_secs < 0)
	{
		rem_secs += 86400;
		days--;
	}

	uint8_t wday = (days % 7) + 3;
	if(wday > 7)
	{
		wday -= 7;
	}

	uint32_t _400y_cycles = days / DAYS_PER_400Y;
	uint32_t rem_days = days % DAYS_PER_400Y;

	if(rem_days < 0)
	{
		rem_days += DAYS_PER_400Y;
		_400y_cycles--;
	}

	uint32_t _100y_cycles = rem_days / DAYS_PER_100Y;
	if(_100y_cycles == 4)
	{
		_100y_cycles--;
	}
	rem_days -= (_100y_cycles * DAYS_PER_100Y);

	uint32_t _4y_cycles = rem_days / DAYS_PER_4Y;
	if(_4y_cycles == 25)
	{
		_4y_cycles--;
	}
	rem_days -= (_4y_cycles * DAYS_PER_4Y);

	uint32_t rem_years = rem_days / 365;
	if(rem_years == 4)
	{
		rem_years --;
	}
	rem_days -= (rem_years * 365);

	uint16_t leap = !rem_years && (_4y_cycles || !_100y_cycles);
	uint16_t yday = rem_days + 31 + 28 + leap;

	if(yday > (365 + leap))
	{
		yday -= (365 + leap);
	}

	uint32_t years = rem_years + (4 * _4y_cycles) + (100 * _100y_cycles) + (400 * _400y_cycles);

	uint8_t months;
	for(months = 0; days_in_month[months] <= rem_days; months++)
	{
		rem_days -= days_in_month[months];
	}

	NTP_TIME->year = years;
	NTP_TIME->month = months + 3;
	if(NTP_TIME->month > 12)
	{
		NTP_TIME->month -= 12;
		NTP_TIME->year++;
	}
	NTP_TIME->year += 2000; //since we calculated from year 2000

	NTP_TIME->date = rem_days + 1;
	NTP_TIME->day = wday;

	NTP_TIME->hour = rem_secs / 3600;
	NTP_TIME->min = (rem_secs / 60) % 60;
	NTP_TIME->sec = rem_secs % 60;

	/////////////////////////////////////////////////////////

	//set to redraw all the time components
	NTP_TIME->draw_update_flag = 0x7F;
	}


void ICACHE_FLASH_ATTR application_ntp_udp_listener_cb(void* arg, char* pdata, uint16_t len)
{
	//CALLBACK FUNCTION FOR NTP REPLY

	//received reply from ntp server
	//stop the ntp server switch timer
	//ntp successfull
	os_timer_disarm(&ntp_server_timer);
	ntp_switch_ip_timer_started = 0;
	ntp_current_server_index = 0;
	ntp_successfull = 1;

	os_printf("received NTP message of len %d\n", len);
	//extract the 32 bit timestamp from ntp reply
	uint32_t a = pdata[40];
	uint32_t b = pdata[41];
	uint32_t c = pdata[42];
	uint32_t d = pdata[43];

	NTP_TIME->time_tick = (a << 24) | (b << 16) | (c << 8) | d;

	os_printf("ntp timestamp %d\n", NTP_TIME->time_tick);

	//reset timer tick count
	timer_tick_count = 0;

	//populate time parameters from the timestamp
	application_get_time_components_from_ntp_timestamp();

	application_print_time();
}
